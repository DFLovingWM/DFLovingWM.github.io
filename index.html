<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="分享技术心得">
<meta name="keywords" content="Web前端">
<meta property="og:type" content="website">
<meta property="og:title" content="大肥凯">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="大肥凯">
<meta property="og:description" content="分享技术心得">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="大肥凯">
<meta name="twitter:description" content="分享技术心得">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>大肥凯</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">大肥凯</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/10/22/JS：探究Generator/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JK">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大肥凯">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/22/JS：探究Generator/" itemprop="url">Untitled</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-10-22T10:19:26+08:00">
                2018-10-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Generator（与Generator Function）</p>
<ul>
<li>对yield/return的理解；传参(next、return、throw)与返回值</li>
<li>异常处理</li>
<li>需要手写执行器，保持异步调用方式的一致性（thunk、Promise）<ul>
<li>co</li>
</ul>
</li>
<li>异步任务控制流</li>
<li>实现一个co模块（用generator模拟async/await）</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/10/22/JS：探究Promise/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JK">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大肥凯">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/22/JS：探究Promise/" itemprop="url">Untitled</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-10-22T09:40:08+08:00">
                2018-10-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="认识Promise"><a href="#认识Promise" class="headerlink" title="认识Promise"></a>认识Promise</h2><h2 id="实现Promise"><a href="#实现Promise" class="headerlink" title="实现Promise"></a>实现Promise</h2>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/10/22/JS：异步编程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JK">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大肥凯">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/22/JS：异步编程/" itemprop="url">JS：异步编程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-10-22T09:00:00+08:00">
                2018-10-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>现提供两个接口：</p>
<ul>
<li>getToken()：获取token</li>
<li>getProductList(token)：查询商品列表</li>
</ul>
<p>为了方便我们直接在前端设置假数据：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> TOKEN = <span class="string">'f23iuf_uy2fujvj9bjsf89b9f8v9vw_e'</span></span><br><span class="line"><span class="keyword">const</span> DATA = [</span><br><span class="line">  &#123;</span><br><span class="line">    id: <span class="string">'1'</span>,</span><br><span class="line">    name: <span class="string">'商品1'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    id: <span class="string">'2'</span>,</span><br><span class="line">    name: <span class="string">'商品2'</span></span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>然后一开始接口定义是类似于Node的error-first的回调形式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getToken</span> (<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    fn(<span class="literal">null</span>, TOKEN)</span><br><span class="line">  &#125;, <span class="built_in">Math</span>.random() * <span class="number">5</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getProductList</span> (<span class="params">token, fn</span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    fn(<span class="literal">null</span>, DATA)</span><br><span class="line">  &#125;, <span class="built_in">Math</span>.random() * <span class="number">5</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="异步调用方式"><a href="#异步调用方式" class="headerlink" title="异步调用方式"></a>异步调用方式</h2><h3 id="1-回调"><a href="#1-回调" class="headerlink" title="1. 回调"></a>1. 回调</h3><p>嵌套太深形成callback hell：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">getToken(<span class="function">(<span class="params">error, token</span>) =&gt;</span> &#123;</span><br><span class="line">  getProductList(token, (error, productList) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(productList)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="2-Promise"><a href="#2-Promise" class="headerlink" title="2. Promise"></a>2. Promise</h3><p>ES6 Promise相对于回调，是一种全新的异步调用方式(Promise A+规范)，它解决了callback hell的问题，将嵌套调用的代码转化为链式调用。</p>
<p>但Promise也带来了一些缺点如：写法略繁琐、API标记多但语义不够清晰等。对于开头例子，首先需要将error-first风格API转换成Promise风格，为此我们设计一个“promisify”方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">promisify</span> (<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> params = <span class="keyword">new</span> <span class="built_in">Array</span>(fn.length - <span class="number">1</span>)</span><br><span class="line">      <span class="comment">// 只取n-1个参数</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; fn.length - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        params[i] = args[i]</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 调用。在回调函数中将结果传给Promise</span></span><br><span class="line">      fn(...params, (err, data) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">          reject(err)</span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        resolve(data)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面是粗略写法，更规范的定义请参考：异步封装库bludbird的promisify，或Node.js v8.0.0版本新增的util.promisify。然后利用该工具方法，重新定义接口：函数以“Async”结尾，表示调用后返回一个Promise(参考bluebird的promisifyAll方法的理念)：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> getTokenAsync = promisify(getToken)</span><br><span class="line"><span class="keyword">let</span> getProductListAsync = promisify(getProductList)</span><br></pre></td></tr></table></figure>
<p>然后是调用接口的代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">getTokenAsync()</span><br><span class="line">.then(</span><br><span class="line">  token =&gt; getProductListAsync(token),</span><br><span class="line">  <span class="literal">null</span></span><br><span class="line">)</span><br><span class="line">.then(</span><br><span class="line">  <span class="built_in">console</span>.log,</span><br><span class="line">  <span class="literal">null</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h3 id="3-Generator"><a href="#3-Generator" class="headerlink" title="3. Generator"></a>3. Generator</h3><p>Generator与Iterator拥有共同的方法：next，但其最大的作用不是遍历，而是通过next和yield这两个关键字，将程序的控制流在两个时空不断转移，因此可以用作异步调用的一种模式，具体来说是将异步代码转化为同步调用的方式(体现在Generator Function中)。但是，它总是需要一个执行器(executor)，来接管异步流程的部分。即它的组成有：</p>
<ul>
<li>Generator Function(以下成为GF)：业务逻辑，写法上类似于同步代码</li>
<li>executor：接管异步部分</li>
</ul>
<p>基于刚才定义的Promise风格的接口，我们为其写一个GF：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> * <span class="title">fetchProductList</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> token = <span class="keyword">yield</span> getTokenAsync()</span><br><span class="line">  <span class="keyword">let</span> productList = <span class="keyword">yield</span> getProductListAsync(token)</span><br><span class="line">  <span class="built_in">console</span>.log(productList)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后是executor部分：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> generator = fetchProductList()</span><br><span class="line"></span><br><span class="line">generator.next().value</span><br><span class="line">.then(</span><br><span class="line">  token =&gt; generator.next(token).value</span><br><span class="line">)</span><br><span class="line">.then(</span><br><span class="line">  productList =&gt; generator.next(productList)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>但我们发现，实际上executor的工作是重复的：每次获取一个Promise，将其resolve之后，把结果返回给GF，周而复始直到没有Promise可取(即在GF中遇到显式或隐式的return语句)。于是“自动执行器”应运而生，由于是迭代(通常所说的迭代，包括循环和递归，然而你会发现在这里只能是递归，因为循环在异步中不管用)地处理每个yield的值，所以，它<u>基于一个前提，就是异步函数返回统一的接口形式</u>。而这些形式，包括但不限于：</p>
<ul>
<li>Thunk函数</li>
<li>Promise</li>
</ul>
<p>Thunk函数又是一个额外但有趣的知识点，阮一峰老师在《ES6标准入门》中有着非常好的介绍。说回Promise，上述的promisify转化方法，其实就是为了将error-first接口转化为统一的Promise形式，才能让自动执行器处理。</p>
<p>自动执行器的一种粗略实现：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span> (<span class="params">generator</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">next</span> (<span class="params">param</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> &#123; done, value &#125; = generator.next(param)</span><br><span class="line">    <span class="keyword">if</span> (done) &#123;</span><br><span class="line">      generator.next(value)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 此时(根据约定)，value是一个Promise</span></span><br><span class="line">    value.then(</span><br><span class="line">      resolvedResult =&gt; &#123;</span><br><span class="line">        next(resolvedResult) <span class="comment">// 递归</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="literal">null</span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  next()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用该executor：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run(fetchProductList())</span><br></pre></td></tr></table></figure>
<p>率先实现自动执行器的库当属TJ的<a href="https://github.com/tj/co" target="_blank" rel="noopener">co</a>。</p>
<h3 id="4-async-await"><a href="#4-async-await" class="headerlink" title="4. async/await"></a>4. async/await</h3><h4 id="4-1-本质"><a href="#4-1-本质" class="headerlink" title="4.1 本质"></a>4.1 本质</h4><p>async/await实际上实现了Generator的Promise风格的自动执行器，即内置了一个类似于上一个例子中的run的执行器。与Generator/yield相比，它在语法上的特点是：</p>
<ul>
<li>Generator Function替换成Async Function(*替换成async)</li>
<li>yield替换成await</li>
</ul>
<p>async意味着函数涉及到异步操作，await表示等待某个具体的异步操作，可见比Generator有着更好的语义。它本质上<u>是一个Promise，在这个大的Promise中它resolve了N个Promise</u>。它的结构可以描述为：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// E为参数的类型，T为return的对象的类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步函数返回一个Promise</span></span><br><span class="line"><span class="keyword">interface</span> AsyncFunction&lt;E, T&gt; &#123;</span><br><span class="line">  (firstParam: E): <span class="built_in">Promise</span>&lt;T&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通函数</span></span><br><span class="line"><span class="keyword">interface</span> Function&lt;E, T&gt; &#123;</span><br><span class="line">  (param: E): T</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-2-理解"><a href="#4-2-理解" class="headerlink" title="4.2 理解"></a>4.2 理解</h4><p>还是那个例子，经过简单的关键字转换后，可以得到一个Async Function：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fetchProductList</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> token = <span class="keyword">await</span> getTokenAsync()</span><br><span class="line">  <span class="keyword">let</span> productList = <span class="keyword">await</span> getProductListAsync(token)</span><br><span class="line">  <span class="built_in">console</span>.log(productList)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要执行该async function，和普通函数调用无异，就是简单的一句：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fetchProductList()</span><br></pre></td></tr></table></figure>
<p>然而，async function是一个大Promise，那如果我们想要获取这个大Promise的结果，还是要对其进行resolve：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fetchProductList().then(</span><br><span class="line">  <span class="built_in">console</span>.log,</span><br><span class="line">  <span class="literal">null</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// fetchProductList函数无return语句，是隐式的"return undefined"，所以打印出：undefined</span></span><br></pre></td></tr></table></figure>
<p>看起来有点繁琐，因为结果顶层Promise还是要使用promise的一般语法来resolve，除非这个Promise又包含在别的async function中才能使用await将其resolve。针对这个情况，<a href="https://github.com/standard-things/esm#readme" target="_blank" rel="noopener">esm库</a>支持了顶层await。</p>
<h4 id="4-3-异步场景"><a href="#4-3-异步场景" class="headerlink" title="4.3 异步场景"></a>4.3 异步场景</h4><p>异步任务控制流，需要从两个方面去区分/选择：</p>
<ol>
<li><p>任务是并行的还是有序的</p>
</li>
<li><p>结果顺序是否稳定</p>
</li>
</ol>
<p>例如有以下Promise风格的接口，模拟一个进行网络请求的任务，等待时间不确定：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getResultAsync</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> waitTime = <span class="built_in">Math</span>.random() * <span class="number">1000</span> <span class="comment">// 等待1秒以内</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      resolve(&#123;</span><br><span class="line">        data: n</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;, waitTime)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么对于业务来说有四种场景可以选用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 过程有序，结果有序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">runOrderly</span> (<span class="params">params</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> results = []</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> n <span class="keyword">of</span> params) &#123;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> getResultAsync(n) <span class="comment">// 解释(1)</span></span><br><span class="line">    results.push(result)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(results)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 过程并行，结果随意(不稳定)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">runRandomly</span> (<span class="params">params</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> results = []</span><br><span class="line">  params.forEach(<span class="keyword">async</span> n =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> getResultAsync(n)</span><br><span class="line">    results.push(result)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (results.length === params.length) &#123; <span class="comment">// 判断是否所有任务都结束了</span></span><br><span class="line">      <span class="built_in">console</span>.log(results)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 过程并行，结果有序：</span></span><br><span class="line"><span class="comment"> * 使用map来并行执行，然后for循环顺序await来获取结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">run1</span> (<span class="params">params</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> promises = params.map(getResultAsync)</span><br><span class="line">  <span class="keyword">const</span> results = []</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> promise <span class="keyword">of</span> promises) &#123;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> promise <span class="comment">// 解释(2)</span></span><br><span class="line">    results.push(result)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(results)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 过程并行，结果有序</span></span><br><span class="line"><span class="comment"> * 使用Promise.all</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">run2</span> (<span class="params">params</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> results = <span class="keyword">await</span> <span class="built_in">Promise</span>.all(params.map(getResultAsync))</span><br><span class="line">  <span class="built_in">console</span>.log(results)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面我标出了两个使用了await的地方需要解释：</p>
<p>（1）该await出现在for循环中、紧跟着异步函数，所以其效果是等待异步函数执行并取出结果，对于整个循环而言，后面的任务都在等待着前面的，所以过程是顺序的。</p>
<p>（2）这次await出现之前，所有异步任务已经(作为map函数回调)被执行了，所以过程是并行的。此await的效果只是等待并获取返回值，所以在结果上表现为顺序/稳定。</p>
<p>另外可以看到使用Promise.all这个API很方便，它的特点是：</p>
<ul>
<li>接收Promise数组，返回一个Promise(resolve的结果是传入Promise数组全被resolve的结果)</li>
<li>返回一个Promise</li>
</ul>
<p>所以可以这样实现：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">PromiseAll</span> (<span class="params">promises</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> results = []</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> promise <span class="keyword">of</span> promises) &#123;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> promise</span><br><span class="line">    results.push(result)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> results</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>可见回调之后的异步编程模式，核心都是Promise。所以下次博客的内容是探究并实现一个Promise。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/10/15/Vue：列表key的作用/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JK">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大肥凯">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/15/Vue：列表key的作用/" itemprop="url">Untitled</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-10-15T09:56:08+08:00">
                2018-10-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/29/JS：数组去重/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JK">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大肥凯">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/29/JS：数组去重/" itemprop="url">数组去重</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-09-29T21:45:00+08:00">
                2018-09-29
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>数组去重，关键在于怎么去判断两个值/对象是否“重复”。想要实现一个去重函数，可以分为两种情况去探究：</p>
<ul>
<li>所有元素都为基本类型</li>
<li>存在对象类型</li>
</ul>
<h2 id="1-基本类型"><a href="#1-基本类型" class="headerlink" title="1. 基本类型"></a>1. 基本类型</h2><h3 id="1-1-利用Set实现"><a href="#1-1-利用Set实现" class="headerlink" title="1.1 利用Set实现"></a>1.1 利用Set实现</h3><p>对于基本类型，我们一般认为全等(===)即重复。实现基本类型数组的去重很简单(这里有一道<a href="http://scriptoj.mangojuice.top/problems/89" target="_blank" rel="noopener">题目</a>)，可以利用ES6的Set，因为一个集合内元素是不重复的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> unique = <span class="function">(<span class="params">arr</span>) =&gt;</span> <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(arr))</span><br></pre></td></tr></table></figure>
<h3 id="1-2-利用indexOf-lastIndexOf实现"><a href="#1-2-利用indexOf-lastIndexOf实现" class="headerlink" title="1.2 利用indexOf/lastIndexOf实现"></a>1.2 利用indexOf/lastIndexOf实现</h3><p>第二种方法，是使用indexOf/lastIndexOf。关键是只取第一次出现的元素，这样就算有重复的也被过滤掉了：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> unique = <span class="function">(<span class="params">arr</span>) =&gt;</span> arr.filter(<span class="function">(<span class="params">item, index, array</span>) =&gt;</span> array.indexOf(item) === index)</span><br></pre></td></tr></table></figure>
<h2 id="2-对象类型"><a href="#2-对象类型" class="headerlink" title="2. 对象类型"></a>2. 对象类型</h2><p>如何判断两个对象是否重复？这要取决于具体的业务场景。有时候我们认为两个对象地址相等即重复，更多时候我们认为id相等即重复……因为重复的标准并不确定，所以当我们实现一个去重函数的时候，需要把不确定的部分作为回调函数交给用户代码去定义。</p>
<h3 id="2-1-基础函数"><a href="#2-1-基础函数" class="headerlink" title="2.1 基础函数"></a>2.1 基础函数</h3><p>我们可以先定义一个底层方法，作为去重的基础函数。算法思路很简单、直接，就是维护一个不重复的数组arr，每次要加入新元素A之前，先让A与arr中的每一个元素相比较，如果都不重复，才把A加进去。具体代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 去重</span></span><br><span class="line"><span class="comment"> * @param &#123;array&#125; array 数组</span></span><br><span class="line"><span class="comment"> * @param &#123;function&lt;boolean&gt;&#125; dupPredicate 回调函数，判断两者“重复”的依据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_unique</span> (<span class="params">array, dupPredicate</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> uniqueArray = []</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> nextElement <span class="keyword">of</span> array) &#123;</span><br><span class="line">    <span class="keyword">let</span> canPush = <span class="literal">true</span></span><br><span class="line">    <span class="comment">// 跟新数组的每一个元素比较</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> element <span class="keyword">of</span> uniqueArray) &#123;</span><br><span class="line">      <span class="keyword">if</span> (dupPredicate(element, nextElement)) &#123;</span><br><span class="line">        <span class="comment">// 一旦发现有相同的，就不能加入新数组了</span></span><br><span class="line">        canPush = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 都不相同，就加入</span></span><br><span class="line">    <span class="keyword">if</span> (canPush) &#123;</span><br><span class="line">      uniqueArray.push(nextElement)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> uniqueArray</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-应用函数"><a href="#2-2-应用函数" class="headerlink" title="2.2 应用函数"></a>2.2 应用函数</h3><p>然后，基于这个函数，我们可以实现：</p>
<ul>
<li>基本类型的去重：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">uniq</span> (<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> _unique(array, (val1, val2) =&gt; val1 === val2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>对象类型，基于某个字段全等的去重：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">uniqBy</span> (<span class="params">array, path</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> _unique(array, (obj1, obj2) =&gt; get(obj1, path) === get(obj2, path))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 辅助函数，用来取对象树的某个(任意深层的)属性</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">get</span> (<span class="params">obj, path</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = obj <span class="comment">// 从顶层开始</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> field <span class="keyword">of</span> path.split(<span class="string">'.'</span>)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (result === <span class="literal">undefined</span> || result === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    result = result[field] <span class="comment">// 不断深入</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>对象类型，用户自定义“重复”的标准，其实就是_unique函数本身：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> uniqWith = _unique</span><br></pre></td></tr></table></figure>
<h3 id="2-3-Lodash"><a href="#2-3-Lodash" class="headerlink" title="2.3 Lodash"></a>2.3 Lodash</h3><p>之所以命名为uniq、uniqBy、uniqWith，是因为在Lodash中存在有这三个函数，它们的作用与上述一致，只是具体实现方法不同。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/18/JS：判断类型/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JK">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大肥凯">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/18/JS：判断类型/" itemprop="url">JS：判断类型</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-09-18T09:03:00+08:00">
                2018-09-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-方法"><a href="#1-方法" class="headerlink" title="1. 方法"></a>1. 方法</h2><h3 id="1-1-typeof"><a href="#1-1-typeof" class="headerlink" title="1.1 typeof"></a>1.1 typeof</h3><h3 id="1-2-instanceof"><a href="#1-2-instanceof" class="headerlink" title="1.2 instanceof"></a>1.2 instanceof</h3><h3 id="1-3-toString"><a href="#1-3-toString" class="headerlink" title="1.3 toString"></a>1.3 toString</h3><h3 id="1-4-constructor-name"><a href="#1-4-constructor-name" class="headerlink" title="1.4 constructor.name"></a>1.4 constructor.name</h3><h3 id="1-5-总结"><a href="#1-5-总结" class="headerlink" title="1.5 总结"></a>1.5 总结</h3><table>
<thead>
<tr>
<th></th>
<th>typeof</th>
<th>instanceof</th>
<th>toString</th>
<th>constructor.name</th>
</tr>
</thead>
<tbody>
<tr>
<td>6种基本类型</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Object及其衍生类型</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>自定义类型</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="2-实现"><a href="#2-实现" class="headerlink" title="2. 实现"></a>2. 实现</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> type = <span class="function">(<span class="params">x</span>) =&gt;</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/06/JS：数组flatten/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JK">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大肥凯">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/06/JS：数组flatten/" itemprop="url">JS：数组flatten</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-09-06T14:45:00+08:00">
                2018-09-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>数组的扁平化/拍平(flatten)，是将多维/嵌套数组转化为一维数组的过程。经常作为面试题出现在前端人的视野中。它有很多种实现方式，本文就来探讨一下。</p>
<h2 id="1-循环concat"><a href="#1-循环concat" class="headerlink" title="1. 循环concat"></a>1. 循环concat</h2><h3 id="1-1-重新认识concat"><a href="#1-1-重新认识concat" class="headerlink" title="1.1 重新认识concat"></a>1.1 重新认识concat</h3><p>Array.prototype.concat，最常见的用法是连接两个数组：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>].concat([<span class="number">2</span>])	<span class="comment">// =&gt; [1, 2]</span></span><br></pre></td></tr></table></figure>
<p>然而它的功能远远不止这个，我们不妨读一下<a href="https://www.ecma-international.org/ecma-262/5.1/#sec-15.4.4.4" target="_blank" rel="noopener">ECMA262声明：Array.prototype.concat</a>。首先要重新认识这个方法：</p>
<ul>
<li>返回结果：一个新数组。同时不改变传入的数组，所以是个immutable的方法。</li>
<li>参数：接受0到多个参数，每个参数可以是数组类型或其它类型。对两种类型的处理方式不一样，简单来说：<ul>
<li>当参数为数组时，将该数组里的每个元素都加进结果中。</li>
<li>当参数不为数组时，直接将它加进结果中。</li>
</ul>
</li>
</ul>
<h3 id="1-2-concat实现一层flatten"><a href="#1-2-concat实现一层flatten" class="headerlink" title="1.2 concat实现一层flatten"></a>1.2 concat实现一层flatten</h3><p>因为concat的参数可以是数组或值，所以可以对数组进行一层flatten(“浅”flatten，类比“浅”拷贝)：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flattenOneLevel</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [].concat(...arr)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">flattenOneLevel( [ <span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>], <span class="number">4</span>, <span class="number">5</span> ] ) <span class="comment">// 传入一层嵌套数组，可以得到期望结果：[1,2,3,4,5]</span></span><br><span class="line">flattenOneLevel( [ <span class="number">1</span>, [ <span class="number">2</span>, [<span class="number">3</span>] ], <span class="number">4</span>, <span class="number">5</span> ] ) <span class="comment">// 结果：[1,2,[3],4,5]</span></span><br></pre></td></tr></table></figure>
<h3 id="1-3-实现通用flatten"><a href="#1-3-实现通用flatten" class="headerlink" title="1.3 实现通用flatten"></a>1.3 实现通用flatten</h3><p>既然一次concat可以实现一层flatten，那么对于多重嵌套数组，我们可以通过多次调用concat，来达到最终的扁平化</p>
<h4 id="1-3-1-深flatten"><a href="#1-3-1-深flatten" class="headerlink" title="1.3.1 深flatten"></a>1.3.1 深flatten</h4><p>相对于“浅flatten”，“深flatten”就是循环调用浅flatten，直到数组中所有元素都不是Array类型：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> ( arr.some( <span class="built_in">Array</span>.isArray ) ) &#123;</span><br><span class="line">    arr = flattenOneLevel(arr)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下全部打印出[1,2,3,4,5]，符合期望</span></span><br><span class="line"><span class="built_in">console</span>.log( flatten( [ <span class="number">1</span>, [ <span class="number">2</span>, <span class="number">3</span> ], <span class="number">4</span>, <span class="number">5</span> ] ) )</span><br><span class="line"><span class="built_in">console</span>.log( flatten( [ <span class="number">1</span>, [ <span class="number">2</span>, [<span class="number">3</span>] ], <span class="number">4</span>, <span class="number">5</span> ] ) )</span><br><span class="line"><span class="built_in">console</span>.log( flatten( [[[[], <span class="number">1</span>, [], [<span class="number">2</span>, <span class="number">3</span>, [<span class="number">4</span>]]]], <span class="number">5</span>] ) )</span><br></pre></td></tr></table></figure>
<h4 id="1-3-2-决定flatten层数的flatten"><a href="#1-3-2-决定flatten层数的flatten" class="headerlink" title="1.3.2 决定flatten层数的flatten"></a>1.3.2 决定flatten层数的flatten</h4><p><a href="https://www.jianshu.com/p/b1fb3434e1f5" target="_blank" rel="noopener">JS 扁平化（flatten） 数组</a>这篇博文有提到：</p>
<blockquote>
<p>lodash 分为浅扁平化和深扁平化(deepFlatten)两个方法。</p>
</blockquote>
<p>同时提到，lodash实现的是让用户决定对参数进行多少次“浅flatten”。具体可以参考<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/flat" target="_blank" rel="noopener">MDN：Array.prototype.flat</a>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span> (<span class="params">arr, shallowCount = <span class="number">1</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (shallowCount--) &#123;</span><br><span class="line">        arr = flattenOneLevel(arr)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = [ <span class="number">1</span>, [ <span class="number">2</span>, [<span class="number">3</span>] ], <span class="number">4</span> ]</span><br><span class="line"><span class="built_in">console</span>.log( flatten(arr) )	<span class="comment">// 打印出：[1,2,[3],4]</span></span><br><span class="line"><span class="built_in">console</span>.log( flatten(arr, <span class="number">2</span>) )	<span class="comment">// 打印出：[1,2,3,4]</span></span><br></pre></td></tr></table></figure>
<h2 id="2-递归"><a href="#2-递归" class="headerlink" title="2. 递归"></a>2. 递归</h2><h3 id="2-1-有返回值的递归"><a href="#2-1-有返回值的递归" class="headerlink" title="2.1 有返回值的递归"></a>2.1 有返回值的递归</h3><p>基本思路是写一个递归函数flatten，返回以当前node为基础的一个新的扁平化数组。下面两种递归的思路其实是一样的，只是判断元素类型的地方不同，一种在当前结点判断，另一种在递归调用子结点前判断（BTW，这两者也是一般递归应有的特点）。具体的我都写在代码注释里了：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 递归思路1：</span></span><br><span class="line"><span class="comment"> * 对于一个数组，flatten返回一个新的扁平的数组。所以算法为：</span></span><br><span class="line"><span class="comment"> * (1)遍历元素：</span></span><br><span class="line"><span class="comment"> *  (1.1)如果元素为值，直接push该值</span></span><br><span class="line"><span class="comment"> *  (1.2)如果元素为数组，对该元素进行递归，然后将结果打散成N个值，然后push进来</span></span><br><span class="line"><span class="comment"> * (2)返回数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> flatten = <span class="function">(<span class="params">arr</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> tmpResult = []</span><br><span class="line">  arr.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(item)) &#123;</span><br><span class="line">      tmpResult.push(...flatten(item))</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      tmpResult.push(item)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> tmpResult</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 递归思路2：</span></span><br><span class="line"><span class="comment"> * 对于一个node(不论类型)，flatten总能返回一个新的扁平的数组。所以算法为：</span></span><br><span class="line"><span class="comment"> * (1.1)如果node为值，则返回[node]</span></span><br><span class="line"><span class="comment"> * (1.2)如果node为Array，则遍历元素进行递归，并将返回的每一个数组都合并起来(用push(...arr)或concat(arr))</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> flatten = <span class="function">(<span class="params">node</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(node)) &#123;</span><br><span class="line">    <span class="keyword">return</span> [node]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> result = []</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> n <span class="keyword">of</span> node) &#123;</span><br><span class="line">    result.push(...flatten(n))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-无返回值的递归"><a href="#2-2-无返回值的递归" class="headerlink" title="2.2 无返回值的递归"></a>2.2 无返回值的递归</h3><p>递归方法还有一个思路，就是设定一个全局数组，然后对目标数组进行DFS，每找到一个值，就push到这个全局数组中，直到结束。当然，为了避免使用全局变量，可以在函数中使用闭包并让其立即执行；或者把该全局变量设置为递归函数的参数（当然这些都是题外话了）。代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> flatten2 = <span class="function">(<span class="params">arr</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> result = [] <span class="comment">// “全局”数组</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> dfs = <span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(x)) &#123;</span><br><span class="line">      result.push(x)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      x.forEach(dfs)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  dfs(arr) <span class="comment">// 从顶层结点开始dfs</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-trick：利用join"><a href="#3-trick：利用join" class="headerlink" title="3. trick：利用join"></a>3. trick：利用join</h2><p>如果数组的值只会是number，那么还有一种取巧的方式可以进行flatten，就是利用Array.prototype.join方法。数组通过join可以转化为字符串，这个过程中，即使是嵌套数组，转为字符串时会忽略嵌套、只取其实质结点。所以算法的思路就是，先join转为字符串，再split转回为数组：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> flatten = <span class="function">(<span class="params">arr</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!arr.length) <span class="keyword">return</span> [] <span class="comment">// 处理特殊情况</span></span><br><span class="line">  <span class="keyword">return</span> arr.join().split(<span class="string">','</span>).map(<span class="built_in">Number</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然该方法只能适用于特殊场景，并不能作为通用的数组flatten方法之一。在此提出，是想要发散自己的思路，顺便过一过<a href="http://scriptoj.mangojuice.top/problems/94" target="_blank" rel="noopener">这道题目</a>。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.ecma-international.org/ecma-262/5.1/#sec-15.4.4.4" target="_blank" rel="noopener">Array.prototype.concat</a></p>
<p><a href="http://scriptoj.mangojuice.top/problems/94" target="_blank" rel="noopener">ScriptOJ：题目94</a></p>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/flat" target="_blank" rel="noopener">MDN：Array.prototype.flat()</a></p>
<p><a href="https://www.jianshu.com/p/b1fb3434e1f5" target="_blank" rel="noopener">JS 扁平化（flatten） 数组</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/05/JS：slice、substr、substring的区别/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JK">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大肥凯">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/05/JS：slice、substr、substring的区别/" itemprop="url">Untitled</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-09-05T12:32:05+08:00">
                2018-09-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>字符串函数：</p>
<ul>
<li>String.prototype.slice</li>
<li>String.prototype.substr</li>
<li>String.prototype.substring</li>
</ul>
<p>数组函数：</p>
<ul>
<li>Array.prototype.slice</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/05/JS：正则匹配API/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JK">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大肥凯">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/05/JS：正则匹配API/" itemprop="url">JS：匹配正则API</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-09-05T10:48:37+08:00">
                2018-09-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本篇旨在总结正则表达式匹配的API。有些API在String原型上，而有些在RegExp原型上，使用的时候要注意。</p>
<p>重点在于几个知识点：</p>
<ul>
<li>正则模式的“g”全局标志</li>
<li>正则模式的捕获组</li>
</ul>
<h2 id="1-String"><a href="#1-String" class="headerlink" title="1. String"></a>1. String</h2><h3 id="1-1-String-prototype-match"><a href="#1-1-String-prototype-match" class="headerlink" title="1.1 String.prototype.match"></a>1.1 String.prototype.match</h3><p>match返回的是匹配的信息（组）。具体结果会受到“g”和捕获的影响。</p>
<ol>
<li><p>参数：</p>
<p>接受一个RegExp实例，默认参数为空字符串(‘’)。所以当参数为空(即undefined)时，认为能够匹配到下标0：</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'hello'</span>.match();	<span class="comment">// [ '', index: 0, input: 'hello' ]</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>返回结果：</li>
</ol>
<ul>
<li>如果模式中没有全局标志”g“，则匹配到第一个就返回，返回的结果是个“匹配项信息”（一个特殊数组，元素包括匹配的捕获组，还有”input”、”index”。接下来都暂且这样称呼）。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'hello'</span>.match(<span class="regexp">/l/</span>);	<span class="comment">// [ 'l', index: 2, input: 'hello' ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 存在捕获组时</span></span><br><span class="line"><span class="string">'hello1234'</span>.match(<span class="regexp">/([a-z]*)(\d&#123;3&#125;)/</span>)</span><br><span class="line"><span class="comment">// 结果：[ 'hello123', 'hello', '123', index: 0, input: 'hello1234' ]</span></span><br></pre></td></tr></table></figure>
<ul>
<li>如果有“g”，则返回所有匹配项组成的数组。每一个匹配项都是字符串，没有index和input等额外字段：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'hello'</span>.match(<span class="regexp">/l/g</span>);	<span class="comment">// [ 'l', 'l' ]</span></span><br></pre></td></tr></table></figure>
<ul>
<li>如果完全没有匹配，最终结果会返回null（而不是个空数组，这里要小心）：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'hello'</span>.match(<span class="regexp">/hi/</span>);	<span class="comment">// null</span></span><br></pre></td></tr></table></figure>
<p>注意：当“g”和“捕获”同时存在时，match会全局寻找，并且每次匹配会忽略捕获，只返回匹配字串本身。即“g”会覆盖“捕获”。</p>
<h3 id="1-2-String-prototype-search"><a href="#1-2-String-prototype-search" class="headerlink" title="1.2 String.prototype.search"></a>1.2 String.prototype.search</h3><p>search只返回第一次匹配的下标，可以看出其行为并不受“g”影响。</p>
<p>search接收一个RegExp，返回一个Number：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'hello'</span>.search(<span class="regexp">/l/</span>);	<span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="string">'hello'</span>.search(<span class="regexp">/l/g</span>);	<span class="comment">// 2。不受“g”影响</span></span><br><span class="line"></span><br><span class="line"><span class="string">'hello'</span>.search(<span class="regexp">/la/</span>);	<span class="comment">// 无法匹配，则返回-1</span></span><br></pre></td></tr></table></figure>
<h2 id="2-RegExp"><a href="#2-RegExp" class="headerlink" title="2. RegExp"></a>2. RegExp</h2><h3 id="2-1-RegExp-prototype-test"><a href="#2-1-RegExp-prototype-test" class="headerlink" title="2.1 RegExp.prototype.test"></a>2.1 RegExp.prototype.test</h3><p>test用来测试一个模式是否存在于某个字符串中，返回结果是true/false。它的行为受“g”影响，分两种情况：</p>
<ul>
<li>模式中有“g”时，由于是全局匹配，正则实例会维护上一次匹配到的位置(A)，下一次调用时会从位置(A+1)开始寻找；结束之后又会回到字符串的起始位置。举个例子会好理解一些：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">'Hello world!'</span></span><br><span class="line"><span class="keyword">var</span> regexp = <span class="regexp">/o/g</span>	<span class="comment">// 有“g”</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( regexp.test(str) )	<span class="comment">// true。从0开始，匹配下标为4</span></span><br><span class="line"><span class="built_in">console</span>.log( regexp.test(str) )	<span class="comment">// true。从5开始，匹配下标为7</span></span><br><span class="line"><span class="built_in">console</span>.log( regexp.test(str) )	<span class="comment">// false。从8开始（到结尾），无法匹配</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( regexp.test(str) )	<span class="comment">// true。又重新从0开始匹配，匹配下标为4</span></span><br></pre></td></tr></table></figure>
<p>换个例子，假如匹配项可能恰好就是字符串的末尾呢？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">'Hello wo'</span>	<span class="comment">// 结尾是"o"，可以匹配</span></span><br><span class="line"><span class="keyword">var</span> regexp = <span class="regexp">/o/g</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( regexp.test(str) )	<span class="comment">// true。位置4</span></span><br><span class="line"><span class="built_in">console</span>.log( regexp.test(str) )	<span class="comment">// true。位置7</span></span><br><span class="line"><span class="built_in">console</span>.log( regexp.test(str) )	<span class="comment">// false。因为上一次返回true，所以继续往下寻找（结尾的后面），当然找不到</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( regexp.test(str) )	<span class="comment">// 上一次返回false，所以这次从0开始匹配，匹配成功，位置4</span></span><br></pre></td></tr></table></figure>
<p>可以看到，当正则实例匹配失败时，下一次才会从字符串的起始位置开始寻找。</p>
<ul>
<li>模式中没有“g”时，因为不是全局匹配，正则实例不会维护位置，所以其行为就是简单地测试字符串中是否存在这个模式。还是同样的例子（下面全部返回true，匹配到的都是下标为4的位置）：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">'Hello world!'</span></span><br><span class="line"><span class="keyword">var</span> regexp = <span class="regexp">/o/</span>	<span class="comment">// 没有“g”</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( regexp.test(str) )</span><br><span class="line"><span class="built_in">console</span>.log( regexp.test(str) )</span><br><span class="line"><span class="built_in">console</span>.log( regexp.test(str) )</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( regexp.test(str) )</span><br></pre></td></tr></table></figure>
<p>###2.2 RegExp.prototype.exec</p>
<p>exec同样受到“g”的影响，有记忆化行为。它的返回结果类似于String.prototype.match，但每次调用都只返回一个匹配项信息（有index、input的特殊数组），也支持捕获。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">'Hello wo'</span></span><br><span class="line"><span class="keyword">let</span> regexp = <span class="regexp">/(o)/g</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> matchItem</span><br><span class="line"><span class="keyword">let</span> matchItems = []</span><br><span class="line"><span class="keyword">let</span> lastIndex = []</span><br><span class="line"><span class="keyword">while</span> ( (matchItem = regexp.exec(str)) != <span class="literal">null</span> ) &#123;</span><br><span class="line">  matchItems.push( matchItem )</span><br><span class="line">  lastIndex.push( regexp.lastIndex )	<span class="comment">// regexp的记忆信息中，lastIndex表示下一次寻找的开始位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="string">`</span></span><br><span class="line"><span class="string">matchItems =&gt;</span></span><br><span class="line"><span class="string">[ [ 'o', index: 4, input: 'Hello world!' ],</span></span><br><span class="line"><span class="string">  [ 'o', index: 7, input: 'Hello world!' ] ]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">lastIndex =&gt; [ 5, 8 ]</span></span><br><span class="line"><span class="string">`</span></span><br></pre></td></tr></table></figure>
<p>其实，正则实例的lastIndex属性，就充分说明了其寻找的过程，跟上面test函数部分我的描述差不多。</p>
<h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><p>这几个函数返回的信息量不同，从小到大依次是：</p>
<ol>
<li>RegExp.prototype.test：返回boolean，表示某次寻找“是否成功”</li>
<li>String.prototype.search：返回number，表示首次匹配到的“下标”</li>
<li>String.prototype.match：返回数组/null，表示首次匹配的匹配信息/所有匹配的字串</li>
<li>RegExp.prototype.exec：返回数组/null，表示某次匹配的匹配信息</li>
</ol>
<h2 id="4-参考"><a href="#4-参考" class="headerlink" title="4. 参考"></a>4. 参考</h2><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/test" target="_blank" rel="noopener">RegExp.prototype.test</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/02/题目：ES6 let声明的循环变量/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JK">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大肥凯">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/02/题目：ES6 let声明的循环变量/" itemprop="url">题目：ES6 let声明的循环变量</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-09-02T14:00:00+08:00">
                2018-09-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>以下代码中，setTimeout会log出什么？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (</span><br><span class="line">	<span class="keyword">let</span> i = <span class="function">(<span class="params"> setTimeout((</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(i); &#125;), <span class="number">0</span> );</span><br><span class="line">    i &lt; <span class="number">2</span>;</span><br><span class="line">    ++i</span><br><span class="line">) &#123;</span><br><span class="line">    ++i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>考察了对ES6的let关键字在for循环中的作用机制。</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ul>
<li><p>对于使用let声明的循环变量，每次循环都是一个独立的局部作用域（lexical scope）。我们可以认为是<u>每次循环、判断语句进行之前，都有一个全新的变量i（next i）诞生，它的值为上一次循环结束时i（last i）的值</u>。相比之下，var声明的循环变量，在整个循环的过程中，只存在唯一一个，每次循环共享一个i。</p>
</li>
<li><p>for中的第一部分即初始化语句，独立于每次循环之外，又是一个新的作用域。</p>
</li>
</ul>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ol>
<li>首先根据逗号表达式，i的初始值是0，但是setTimeout也往事件队列里推进了一个异步输出任务。</li>
<li>然后，根据上述原理所说的，for循环的初始化部分算作一个独立的作用域，与所有循环无关。所以在这个作用域里，i是0。那么轮到异步任务被主线程执行时，i还是0。所以答案，即最终结果输出的是0。</li>
<li>然后才开始循环，而每一轮循环，都相当于创建了一个新的i，与第2步所说的i无关了。</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><p>原视频（Youtube）：<a href="https://www.youtube.com/watch?v=Nzokr6Boeaw&amp;list=PLNYkxOF6rcIAKIQFsNbV0JDws_G_bnNo9" target="_blank" rel="noopener">JavaScript for-loops are… complicated</a></p>
</li>
<li><p>方应杭老师的视频解说：<a href="https://zhuanlan.zhihu.com/p/42566352" target="_blank" rel="noopener">分析HTTP203出的一个JS题目</a></p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">JK</p>
              <p class="site-description motion-element" itemprop="description">分享技术心得</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">32</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">67</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">JK</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
